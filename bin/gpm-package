#!/usr/bin/lua

-- Load globally installed packages
local lfs = require "lfs"
local argparse = require "argparse"

-- Load local packages
folder_of_this = arg[0]:match("(.-)[^\\/]+$") -- Get folder of executeable
if folder_of_this:sub(1,1) ~= "/" then
   folder_of_this = lfs.currentdir() .. "/" .. folder_of_this
end
package.path = folder_of_this .. '../lib/?.lua;' .. package.path -- Set package path
local exception = require "exception"
local path = require "path"
local version = require "version"
local stack = require "stack"
local install = require "install"
local initializer = require "initialize"
local remove = require "remove"
local util = require "util"
local logging = require "logging"
local ansicolor = require "ansicolor"

-- Description of this script
description = {
   script_name = "gpm-package.lua",
   name = "Grendel/Great Package Manager 2000 (GPM2K), or just GPM for short :)",
   desc = "Grendels own easybuilder, yay!",
}

-- Set config defaults
config = {  
   current_directory = lfs.currentdir(),  
   gpk_path = folder_of_this .. "../gpk",
   gps_path = folder_of_this .. "../gps",
   heirarchical = {},
}

--- Log the call to gpm in the stack log-file.
--
-- @param stack  Boolean, are we running a stack command?
--
-- Log the gpm-package call in the stack log-file, adding a date and username of
-- the user who made the call. This creates a log over all
-- calls such that it is easy to see how a package was installed,
-- and by whom.
local function log_gpm_call(stack)
   if config.logfilepath then
      -- Open log file
      local logfile = io.open(config.logfilepath, "a")
      
      -- Create call string
      local call = ""
      for count = 0,#arg do
         if count == 0 then
            call = arg[count]
         else
            call = call .. " " .. arg[count]
         end
      end

      -- Get user who ran the command
      local user = os.getenv("USER")
      if not user then
         user = "INCOGNITO"
      end

      -- Log command
      local msg = ansicolor.yellow .. ansicolor.bold .. "[ " .. os.date("%c") .. " ] ( " .. user .. " ) " .. ansicolor.default .. call
      if stack then
         msg = msg .. ansicolor.blue " ... " .. ansicolor.default .. "Running\n"
      end
      
      logging.message(msg , {logfile}, true)
      logging.message(msg , {io.stdout})

      logfile:close()
   end
end

--- Log success/failure
-- 
-- @param success Boolean, was the call to gpm a success.
-- @param stack   Boolean, are we running stack command.
--
-- Log whether call to gpm-package ended succesfully or with an error.
-- This is written to the stack log-file after the command.
local function log_gpm_call_end(success, stack)
   if config.logfilepath then
      -- Open log file
      local logfile = io.open(config.logfilepath, "a")
      
      -- If stack do extra printout
      if stack then
         -- Get user who ran the command
         local user = os.getenv("USER")
         if not user then
            user = "INCOGNITO"
         end

         local msg = ansicolor.yellow .. ansicolor.bold .. "[ " .. os.date("%c") .. " ] ( " .. user .. " ) " .. ansicolor.default .. "Stack call"
         logging.message(msg, {logfile}, true)
      end
      
      -- Print success/fail
      if success then
         logging.message("Success!", {logfile})
      else
         logging.alert("Failed!", {logfile})
      end
      
      -- Close the log file
      logfile:close()
   end
end

-------------------------------------
-- Read GPM package file (GPK).
--
-- @return{Dictionary} Returns definition og build.
-------------------------------------
local function bootstrap_config(args, default_config)
   if args.debug then
      logging.debug("Bootstrapping config.", io.stdout)
   end
   
   -- Make sure we have a config
   if not args.config then
      -- If none was given we check for the environtment one.
      config_path = os.getenv("GPM_CONFIG")
      if config_path then
         args.config = config_path
      else
         -- If enviroment config wasn't found, we check current directory
         args.config = path.join(config.current_directory, "config.lua")
      end
   end

   assert(loadfile(args.config))()

   default_config = util.merge(default_config, config)

   if config.gpk_path then
      default_config.gpk_path = default_config.gpk_path .. ":" .. folder_of_this .. "../gpk"
   end
   if config.gps_path then
      default_config.gps_path = default_config.gps_path .. ":" .. folder_of_this .. "../gps"
   end

   if not default_config.base_build_directory then default_config.base_build_directory = default_config.install_directory .. "/build" end
   if not default_config.lmod_directory then default_config.lmod_directory = default_config.install_directory .. "/modulefiles" end

   return default_config
end

-------------------------------------
-- Main driver.
-------------------------------------
function main()

   -- Arg parser
   local parser = argparse(description.script_name, description.name .. ":\n" .. description.desc)
   
   -- Commands
   local parser_initialize = parser:command("initialize") 
   local parser_install = parser:command("install")
   local parser_remove = parser:command("remove")
   local parser_stack = parser:command("stack")
   
   -- Some general arguments
   parser:option("-c --config", "Provide config file."):overwrite(false)
   parser:flag("--debug", "Print debug information (mostly for developers).")
   parser:flag("-v --version", "Print '" .. version.get_version() .. "' and exit."):action(function()
      print(version.get_version())
      os.exit(0)
   end)

   -- Initialize specific
   parser_initialize:option("--parentstack", "Paths to source as GPM parent stacks. Give as comma-separated list."):overwrite(false)
   
   -- Install specific
   parser_install:mutex(
      parser_install:option("--gpk" , "GPM Package (GPK) to install/remove (will look for .gpk file)."):overwrite(false),
      parser_install:option("--gpkf", "GPM Package (GPK) file to install/remove."):overwrite(false)
   )
   parser_install:option("--pkv", "Set Package Version (PKV) of the package to install/remove."):overwrite(false)
   parser_install:option("--prereq", "Set pre-requisites for heirarchical directories. Example --prereq='compiler=gcc/7.1.0,mpi=openmpi/2.1.1'."):overwrite(false)
   parser_install:option("--depends-on", "Load modules before building package, and load modules when loading package with lmod. Example --moduleload='llvm/5.0.0'."):overwrite(false)
   parser_install:option("--moduleload", "Load modules before building package, but do not load modules when loading package with lmod. Example --moduleload='cmake/3.9.4'."):overwrite(false)
   parser_install:option("--source", "Set source. Will overwrite what is set in .gpk."):overwrite(false)
   parser_install:flag("--no-build", "Do not build package.")
   parser_install:flag("--no-lmod", "Do not create Lmod script.")
   parser_install:flag("--force-download", "Force download or copying of source.")
   parser_install:flag("--force-unpack", "Force unpacking of source.")
   parser_install:flag("--delete-source", "Delete the source file after build.")
   parser_install:flag("--keep-build-directory" , "Keep actual build directory.")
   parser_install:flag("--purgebuild" , "Purge by completely removing main build directory after build is complete.")

   -- Remove specific
   parser_remove:mutex(
      parser_remove:option("--gpk" , "GPM Package (GPK) to install/remove (will look for .gpk file)."):overwrite(false),
      parser_remove:option("--gpkf", "GPM Package (GPK) file to install/remove."):overwrite(false)
   )
   parser_remove:option("--pkv", "Set Package Version (PKV) of the package to install/remove."):overwrite(false)
   parser_remove:option("--purge", "Remove package binaries.")
   parser_remove:option("--purgeall", "Remove package binaries and all package binaries hierarchically dependent on this package.")
   parser_remove:option("--prereq", "If the package to removed has any prereqs.")
   
   -- Stack specific
   parser_stack:mutex(
      parser_stack:option("--gps" , "GPM Stack (GPS) to install (will look for .gps file)."):overwrite(false),
      parser_stack:option("--gpsf", "GPM Stack (GPS) file to install."):overwrite(false)
   )
   parser_stack:flag("--cleanup", "Cleanup by removing build directory after build is complete.")
   parser_stack:flag("--no-build", "Do not build packages.")
   parser_stack:flag("--no-lmod", "Do not create Lmod scripts.")
   
   -- Parse arguments
   args = parser:parse()
   if args.debug then
      logging.debug(util.print(args, "args"), io.stdout)
   end
   
   exception.try(function()
      -- Bootstrap config
      config = bootstrap_config(args, config)
      
      -- Log the call to the stack log
      log_gpm_call(args.stack)
      
      -- Switch on command
      if args.initialize then
         -- Initialize command
         initializer.initialize(args)
      elseif args.install then
         -- Install command
         install.install(args)
      elseif args.remove then
         -- Remove Command
         remove.remove(args)
      elseif args.stack then
         -- Stack command
         stack.stack(args)
      end

      -- Log command success
      log_gpm_call_end(true, args.stack)
   end, function(e)
      -- Log command failed
      log_gpm_call_end(false, args.stack)
      
      -- Print exception
      exception.message(e)
         
      -- Print usage
      print("\n" .. parser:get_usage())

      -- Exit with non zero status
      os.exit(1)
   end)
   
   
end

-- Run main driver.
main()

--[[
# vi:syntax=lua
--]]
