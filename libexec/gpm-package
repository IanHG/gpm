-- Load globally installed packages
local lfs      = assert(require "lfs")
local argparse = assert(require "argparse")

-- Load local packages
local exception   = assert(require "lib.exception")
local path        = assert(require "lib.path")
local configload  = assert(require "lib.configload")
local version     = assert(require "lib.version")
local stack       = assert(require "lib.stack")
local install     = assert(require "lib.install")
local initializer = assert(require "lib.initialize")
local remove      = assert(require "lib.remove")
local util        = assert(require "lib.util")
local logging     = assert(require "lib.logging")
local ansicolor   = assert(require "lib.ansicolor")

-- Description of this script
local description = version.get_description("gpm-package.lua")

--- Log the call to gpm in the stack log-file.
--
-- @param stack  Boolean, are we running a stack command?
--
-- Log the gpm-package call in the stack log-file, adding a date and username of
-- the user who made the call. This creates a log over all
-- calls such that it is easy to see how a package was installed,
-- and by whom.
local function log_gpm_call(stack)
   if config.log_path then
      -- Open log file
      local logfile = io.open(config.log_path, "a")
      
      -- Create call string
      local call = ""
      for count = 0,#arg do
         if count == 0 then
            call = arg[count]
         else
            call = call .. " " .. arg[count]
         end
      end

      -- Get user who ran the command
      local user = os.getenv("USER")
      if not user then
         user = "INCOGNITO"
      end

      -- Log command
      local msg = ansicolor.yellow .. ansicolor.bold .. "[ " .. os.date("%c") .. " ] ( " .. user .. " ) " .. ansicolor.default .. call
      if stack then
         msg = msg .. ansicolor.blue " ... " .. ansicolor.default .. "Running\n"
      end
      
      logging.message(msg , {logfile}, true)
      logging.message(msg , {io.stdout})

      logfile:close()
   end
end

--- Log success/failure
-- 
-- @param success Boolean, was the call to gpm a success.
-- @param stack   Boolean, are we running stack command.
--
-- Log whether call to gpm-package ended succesfully or with an error.
-- This is written to the stack log-file after the command.
local function log_gpm_call_end(success, stack)
   if config.log_path then
      -- Open log file
      local logfile = io.open(config.log_path, "a")
      
      -- If stack do extra printout
      if stack then
         -- Get user who ran the command
         local user = os.getenv("USER")
         if not user then
            user = "INCOGNITO"
         end

         local msg = ansicolor.yellow .. ansicolor.bold .. "[ " .. os.date("%c") .. " ] ( " .. user .. " ) " .. ansicolor.default .. "Stack call"
         logging.message(msg, {logfile}, true)
      end
      
      -- Print success/fail
      if success then
         logging.message("Success!", {logfile})
      else
         logging.alert("Failed!", {logfile})
      end
      
      -- Close the log file
      logfile:close()
   end
end


-------------------------------------
-- Main driver.
-------------------------------------
function main()

   -- Arg parser
   local parser = argparse(description.script_name, description.name .. ":\n" .. description.desc)
   
   -- Commands
   local parser_initialize = parser:command("initialize") 
   local parser_install = parser:command("install")
   local parser_remove = parser:command("remove")
   local parser_stack = parser:command("stack")
   
   -- Some general arguments
   parser:option("-c --config", "Provide config file."):overwrite(false)
   parser:flag("--debug", "Print debug information (mostly for developers).")
   parser:flag("-v --version", "Print '" .. version.get_version() .. "' and exit."):action(function()
      print(version.get_version())
      os.exit(0)
   end)

   -- Initialize specific
   parser_initialize:option("--parentstack", "Paths to source as GPM parent stacks. Give as comma-separated list."):overwrite(false)
   
   -- Install specific
   parser_install:mutex(
      parser_install:option("--gpk" , "GPM Package (GPK) to install/remove (will look for .gpk file)."):overwrite(false),
      parser_install:option("--gpkf", "GPM Package (GPK) file to install/remove."):overwrite(false)
   )
   parser_install:option("--pkv", "Set Package Version (PKV) of the package to install/remove."):overwrite(false)
   parser_install:option("--prereq", "Set pre-requisites for heirarchical directories. Example --prereq='compiler=gcc/7.1.0,mpi=openmpi/2.1.1'."):overwrite(false)
   parser_install:option("--depends-on", "Load modules before building package, and load modules when loading package with lmod. Example --moduleload='llvm/5.0.0'."):overwrite(false)
   parser_install:option("--moduleload", "Load modules before building package, but do not load modules when loading package with lmod. Example --moduleload='cmake/3.9.4'."):overwrite(false)
   parser_install:option("--source", "Set source. Will overwrite what is set in .gpk."):overwrite(false)
   parser_install:flag("--no-build", "Do not build package.")
   parser_install:flag("--no-lmod", "Do not create Lmod script.")
   parser_install:flag("--force-download", "Force download or copying of source.")
   parser_install:flag("--force-unpack", "Force unpacking of source.")
   parser_install:flag("--delete-source", "Delete the source file after build.")
   parser_install:flag("--keep-build-directory" , "Keep actual build directory.")
   parser_install:flag("--purgebuild" , "Purge by completely removing main build directory after build is complete.")

   -- Remove specific
   parser_remove:mutex(
      parser_remove:option("--gpk" , "GPM Package (GPK) to install/remove (will look for .gpk file)."):overwrite(false),
      parser_remove:option("--gpkf", "GPM Package (GPK) file to install/remove."):overwrite(false)
   )
   parser_remove:option("--pkv", "Set Package Version (PKV) of the package to install/remove."):overwrite(false)
   parser_remove:option("--purge", "Remove package binaries.")
   parser_remove:option("--purgeall", "Remove package binaries and all package binaries hierarchically dependent on this package.")
   parser_remove:option("--prereq", "If the package to removed has any prereqs.")
   
   -- Stack specific
   parser_stack:mutex(
      parser_stack:option("--gps" , "GPM Stack (GPS) to install (will look for .gps file)."):overwrite(false),
      parser_stack:option("--gpsf", "GPM Stack (GPS) file to install."):overwrite(false)
   )
   parser_stack:flag("--cleanup", "Cleanup by removing build directory after build is complete.")
   parser_stack:flag("--no-build", "Do not build packages.")
   parser_stack:flag("--no-lmod", "Do not create Lmod scripts.")
   
   -- Parse arguments
   args = parser:parse()
   if args.debug then
      logging.debug(util.print(args, "args"), io.stdout)
   end
   
   exception.try(function()
      -- Bootstrap config
      config = configload.bootstrap(args, config)
      
      -- Log the call to the stack log
      log_gpm_call(args.stack)
      
      -- Switch on command
      if args.initialize then
         -- Initialize command
         initializer.initialize(args)
      elseif args.install then
         -- Install command
         install.install(args)
      elseif args.remove then
         -- Remove Command
         remove.remove(args)
      elseif args.stack then
         -- Stack command
         stack.stack(args)
      end

      -- Log command success
      log_gpm_call_end(true, args.stack)
   end, function(e)
      -- Log command failed
      log_gpm_call_end(false, args.stack)
      
      -- Print exception
      exception.message(e)
         
      -- Print usage
      print("\n" .. parser:get_usage())

      -- Exit with non zero status
      os.exit(1)
   end)
   
   
end

--[[
# vi:syntax=lua
--]]
