local lfs = require "lfs"
local argparse = require "argparse"

-- Load local packages
--folder_of_this = arg[0]:match("(.-)[^\\/]+$") -- Get folder of executeable
--if folder_of_this:sub(1,1) ~= "/" then
--   folder_of_this = lfs.currentdir() .. "/" .. folder_of_this
--end
--package.path = folder_of_this .. '../lib/?.lua;' .. package.path -- Set package path
--package.path = '../lib/?.lua;' .. package.path -- Set package path

local exception   = require "lib.exception"
local path        = require "lib.path"
local configload  = require "lib.configload"
local version     = require "lib.version"
local stack       = require "lib.stack"
local install     = require "lib.install"
local initializer = require "lib.initialize"
local remove      = require "lib.remove"
local util        = require "lib.util"
local logging     = require "lib.logging"
local ansicolor   = require "lib.ansicolor"

-- Description of this script
local description = version.get_description("gpm-package.lua")

--- Log the call to gpm in the stack log-file.
--
-- @param stack  Boolean, are we running a stack command?
--
-- Log the gpm-package call in the stack log-file, adding a date and username of
-- the user who made the call. This creates a log over all
-- calls such that it is easy to see how a package was installed,
-- and by whom.
local function log_gpm_call(stack)
   if config.log_path then
      -- Open log file
      local logfile = io.open(config.log_path, "a")
      
      -- Create call string
      local call = ""
      for count = 0,#arg do
         if count == 0 then
            call = arg[count]
         else
            call = call .. " " .. arg[count]
         end
      end

      -- Get user who ran the command
      local user = os.getenv("USER")
      if not user then
         user = "INCOGNITO"
      end

      -- Log command
      local msg = ansicolor.yellow .. ansicolor.bold .. "[ " .. os.date("%c") .. " ] ( " .. user .. " ) " .. ansicolor.default .. call
      if stack then
         msg = msg .. ansicolor.blue " ... " .. ansicolor.default .. "Running\n"
      end
      
      logging.message(msg , {logfile}, true)
      logging.message(msg , {io.stdout})

      logfile:close()
   end
end

--- Log success/failure
-- 
-- @param success Boolean, was the call to gpm a success.
-- @param stack   Boolean, are we running stack command.
--
-- Log whether call to gpm-package ended succesfully or with an error.
-- This is written to the stack log-file after the command.
local function log_gpm_call_end(success, stack)
   if config.log_path then
      -- Open log file
      local logfile = io.open(config.log_path, "a")
      
      -- If stack do extra printout
      if stack then
         -- Get user who ran the command
         local user = os.getenv("USER")
         if not user then
            user = "INCOGNITO"
         end

         local msg = ansicolor.yellow .. ansicolor.bold .. "[ " .. os.date("%c") .. " ] ( " .. user .. " ) " .. ansicolor.default .. "Stack call"
         logging.message(msg, {logfile}, true)
      end
      
      -- Print success/fail
      if success then
         logging.message("Success!", {logfile})
      else
         logging.alert("Failed!", {logfile})
      end
      
      -- Close the log file
      logfile:close()
   end
end

----- Boostrap config dictionary.
---- 
---- @param args
---- @param default_config
----
---- @return{Dictionary} Returns definition og build.
--local function bootstrap_config(args, default_config)
--   if args.debug then
--      logging.debug("Bootstrapping config.", io.stdout)
--   end
--   
--   -- Make sure we have a config
--   if not args.config then
--      -- If none was given we check for the environtment one.
--      config_path = os.getenv("GPM_CONFIG")
--      if config_path then
--         args.config = config_path
--      else
--         -- If enviroment config wasn't found, we check current directory
--         args.config = path.join(config.current_directory, "config.lua")
--      end
--   end
--
--   assert(loadfile(args.config))()
--
--   default_config = util.merge(default_config, config)
--
--   -- 
--   if (not default_config.stack_path) then
--      local stack_path, _, _ = path.split_filename(args.config)
--      print(stack_path)
--      default_config.stack_path = path.remove_dir_end(stack_path)
--   end
--
--   --
--   if default_config.log_path and (not path.is_abs_path(default_config.log_path)) then
--      default_config.log_path = path.join(default_config.stack_path, default_config.log_path)
--   end
--   
--   -- Setup gpk_path and gps_path
--   if config.gpk_path then
--      default_config.gpk_path = default_config.gpk_path .. ":" .. folder_of_this .. "../gpk"
--   end
--   if config.gps_path then
--      default_config.gps_path = default_config.gps_path .. ":" .. folder_of_this .. "../gps"
--   end
--   
--   -- Setup build_path and lmod_path
--   if not default_config.base_build_directory then 
--      default_config.base_build_directory = default_config.stack_path .. "/build" 
--   end
--   if not default_config.lmod_directory then 
--      default_config.lmod_directory = default_config.stack_path .. "/modulefiles" 
--   end
--
--   return default_config
--end

-------------------------------------
-- Main driver.
-------------------------------------
function main()

   -- Arg parser
   local parser = argparse(description.script_name, description.name .. ":\n" .. description.desc)
   
   -- Commands
   local parser_initialize = parser:command("initialize") 
   local parser_install = parser:command("install")
   local parser_remove = parser:command("remove")
   local parser_stack = parser:command("stack")
   
   -- Some general arguments
   parser:option("-c --config", "Provide config file."):overwrite(false)
   parser:flag("--debug", "Print debug information (mostly for developers).")
   parser:flag("-v --version", "Print '" .. version.get_version() .. "' and exit."):action(function()
      print(version.get_version())
      os.exit(0)
   end)

   -- Initialize specific
   parser_initialize:option("--parentstack", "Paths to source as GPM parent stacks. Give as comma-separated list."):overwrite(false)
   
   -- Install specific
   parser_install:mutex(
      parser_install:option("--gpk" , "GPM Package (GPK) to install/remove (will look for .gpk file)."):overwrite(false),
      parser_install:option("--gpkf", "GPM Package (GPK) file to install/remove."):overwrite(false)
   )
   parser_install:option("--pkv", "Set Package Version (PKV) of the package to install/remove."):overwrite(false)
   parser_install:option("--prereq", "Set pre-requisites for heirarchical directories. Example --prereq='compiler=gcc/7.1.0,mpi=openmpi/2.1.1'."):overwrite(false)
   parser_install:option("--depends-on", "Load modules before building package, and load modules when loading package with lmod. Example --moduleload='llvm/5.0.0'."):overwrite(false)
   parser_install:option("--moduleload", "Load modules before building package, but do not load modules when loading package with lmod. Example --moduleload='cmake/3.9.4'."):overwrite(false)
   parser_install:option("--source", "Set source. Will overwrite what is set in .gpk."):overwrite(false)
   parser_install:flag("--no-build", "Do not build package.")
   parser_install:flag("--no-lmod", "Do not create Lmod script.")
   parser_install:flag("--force-download", "Force download or copying of source.")
   parser_install:flag("--force-unpack", "Force unpacking of source.")
   parser_install:flag("--delete-source", "Delete the source file after build.")
   parser_install:flag("--keep-build-directory" , "Keep actual build directory.")
   parser_install:flag("--purgebuild" , "Purge by completely removing main build directory after build is complete.")

   -- Remove specific
   parser_remove:mutex(
      parser_remove:option("--gpk" , "GPM Package (GPK) to install/remove (will look for .gpk file)."):overwrite(false),
      parser_remove:option("--gpkf", "GPM Package (GPK) file to install/remove."):overwrite(false)
   )
   parser_remove:option("--pkv", "Set Package Version (PKV) of the package to install/remove."):overwrite(false)
   parser_remove:option("--purge", "Remove package binaries.")
   parser_remove:option("--purgeall", "Remove package binaries and all package binaries hierarchically dependent on this package.")
   parser_remove:option("--prereq", "If the package to removed has any prereqs.")
   
   -- Stack specific
   parser_stack:mutex(
      parser_stack:option("--gps" , "GPM Stack (GPS) to install (will look for .gps file)."):overwrite(false),
      parser_stack:option("--gpsf", "GPM Stack (GPS) file to install."):overwrite(false)
   )
   parser_stack:flag("--cleanup", "Cleanup by removing build directory after build is complete.")
   parser_stack:flag("--no-build", "Do not build packages.")
   parser_stack:flag("--no-lmod", "Do not create Lmod scripts.")
   
   -- Parse arguments
   args = parser:parse()
   if args.debug then
      logging.debug(util.print(args, "args"), io.stdout)
   end
   
   exception.try(function()
      -- Bootstrap config
      config = configload.bootstrap(args, config)
      
      -- Log the call to the stack log
      log_gpm_call(args.stack)
      
      -- Switch on command
      if args.initialize then
         -- Initialize command
         initializer.initialize(args)
      elseif args.install then
         -- Install command
         install.install(args)
      elseif args.remove then
         -- Remove Command
         remove.remove(args)
      elseif args.stack then
         -- Stack command
         stack.stack(args)
      end

      -- Log command success
      log_gpm_call_end(true, args.stack)
   end, function(e)
      -- Log command failed
      log_gpm_call_end(false, args.stack)
      
      -- Print exception
      exception.message(e)
         
      -- Print usage
      print("\n" .. parser:get_usage())

      -- Exit with non zero status
      os.exit(1)
   end)
   
   
end

--[[
# vi:syntax=lua
--]]
