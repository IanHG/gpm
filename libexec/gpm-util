-- Load globally installed packages
local argparse = assert(require "argparse")

-- Load local packages
local exception  = assert(require "lib.exception")
local path       = assert(require "lib.path")
local version    = assert(require "lib.version")
local util       = assert(require "lib.util")
local logging    = assert(require "lib.logging")
local logger     = logging.logger
local ansicolor  = assert(require "lib.ansicolor")
local configload = assert(require "lib.configload")
local filesystem = assert(require "lib.filesystem")
local database   = assert(require "lib.database")
local lmod       = assert(require "lib.lmod")
local gpackage   = assert(require "lib.gpackage")

-- Description of this script
local description = version.get_description("gpm-util")

--
local function command_lmod(args)
   if args.update_cache then
      lmod.update_lmod_cache()
   end
end

local function command_config_create(args)
   local function basic_config_template()
      return [[
-- GPM config file
config = {
   nprocesses = %nprocesses%,

   -- Main directory
   stack_name = %stack_name%,
   stack_token= "main",
   stack_path = %stack_path%

   -- Setup some paths
   log_path = "stack.log",
   gpk_path = "gpk",
   gps_path = "gps",

   --
   meta_stack = {
      allow_registration = true,
   },
   
   -- Database stuff
   db = {
      path = "db",
   },
   
   --
   lmod = {
      version = %lmod_version%,
      cache_path = "modulesdata",
   },
}
   ]]
   end
   
   -- Create a config template
   local config_template = basic_config_template()
   local symbol_table    = gpackage.create_symbol_table()
   symbol_table:add_symbol("stack_path"  , "\"" .. folder_of_this .. "\"")
   symbol_table:add_symbol("stack_name"  , "\"" .. "Main stack"   .. "\"")
   symbol_table:add_symbol("lmod_version", "\"" .. "7.7.38"       .. "\"")
   symbol_table:add_symbol("nprocesses"  , "4")

   config_template = symbol_table:substitute(config_template)
   
   -- Write the template to file
   local config_file = assert(io.open(path.join(global_config.current_directory, "config.lua"), 'w'))
   config_file:write(config_template)
   config_file:close()
end

local function command_config(args)
   if args.create then
      -- create a config file
      command_config_create(args)
   end
end

local function command_init(args)
end

--- Main driver.
function main()
   -- Arg parser
   local parser = argparse(description.script_name, description.name .. ":\n" .. description.desc)
   
   -- Commands
   local parser_config = parser:command("config", "Manipulate config file.")
   local parser_init   = parser:command("init"  , "Initialize stack.")
   local parser_lmod   = parser:command("lmod"  , "Manipulate Lmod.") 
   
   -- Some general arguments
   parser:option("-c --config", "Provide config file."):overwrite(false)
   parser:option("-t --token"   , "Set a stack token."):overwrite(false)
   parser:flag("--debug", "Print debug information (mostly for developers).")
   parser:flag("-v --version", "Print '" .. version.get_version() .. "' and exit."):action(function()
      print(version.get_version())
      os.exit(0)
   end)
   
   -- config specific
   local parser_config_create = parser_config:command("create", "Create a basic config in current directory.")
   local parser_config_update = parser_config:command("update", "Update config.")
   
   -- lmod specific
   parser_lmod:flag("--update-cache",   "Update Lmod cache for current stack.")
      
   -- Parse arguments
   args = parser:parse()
   
   if args.debug then
      logger:debug("Lua version : " .. _VERSION)
      logger:debug(util.print(args, "args")    )
   end
   
   exception.try(function()
      -- Bootstrap config
      configload.bootstrap(nil, args, {}, true)

      if args.lmod then
         command_lmod(args)
      elseif args.config then
         command_config(args)
      elseif args.init then
         command_init(args)
      end
   end, function(e)
      -- Print exception
      exception.message(e)
         
      -- Print usage
      print("\n" .. parser:get_usage())

      -- Exit with non zero status
      os.exit(1)
   end)
end

--[[
# vi:syntax=lua
--]]
